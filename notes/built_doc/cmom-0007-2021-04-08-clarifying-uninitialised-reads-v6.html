<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#unitialised-reads-v6-summary"><span class="toc-section-number">1</span> Unitialised Reads v6: Summary</a></li>
</ul>
</div>
<h1 id="unitialised-reads-v6-summary"><span class="header-section-number">1</span> Unitialised Reads v6: Summary</h1>
<p>Peter Sewell, Jens Gustedt, Martin Uecker, Kayvan Memarian</p>
<p>2021-04-13</p>
<p>The semantics of uninitialised values and padding bytes in C has long been a vexed question: there are many conceivable semantics, there are conflicting demands and expectations, and the current standard text is not clear about all aspects. This note summarises our view of the design space following recent discussions in WG14 and in the C memory object model. To keep this concise, we focus only on the design options as we see them now, without examples or history.</p>
<p>As the existing standard (with its concepts of trap representation, unspecified value, and indeterminate value) is problematic in various respects (which we do not detail here), we focus on what the semantics should be, and especially on the constraints on it that arise from practice, rather than on what the current standard text says.</p>
<p>C and C++ should ideally be closely aligned for all this, but here we focus just on the C case.</p>
<ul>
<li><p>there are some cases where it has to be deemed an error to read a specific object representation, e.g. to let some implementations trap - these cases are now rare, but they include signalling NaNs and perhaps other exotic number formats.</p></li>
<li><p>there are some cases where it has to be deemed an error to operate on the result of a read of a specific object representation - primarily _Bool and floating-point cases - but where we have a free choice whether to deem it an error to read or write them</p></li>
<li><p>it would be reasonable to require implementations to document the cases where they do each of the above</p></li>
<li><p>copying partially initialised structs has to be allowed (either by an explicit struct read&amp;write, or implicitly as a struct function argument or return value).</p></li>
<li><p>it's unclear whether copying partially initialised structs member-by-member has to be allowed. We tentatively assume not.</p></li>
<li><p>we see no programmer use-case for the current ISO address-taken exception (leaving representation-byte accesses aside), so we can remove that (though we may wish to check that whatever semantics we end up with admits Itanium NaT-like behaviour in case future architectures do that).</p></li>
<li><p>reading the representation bytes of uninitialised automatic storage duration variables and malloc'd regions has to be allowed, eg to support library or user memcpy of partially initialised structs (deferring what one knows about the results of such reads for a moment)</p>
<ul>
<li>in ISO C, representation-byte accesses have to be at character types, but real code also relies on representation-byte accesses at larger types - this is likely rare, but we should support it in some way. There is also type-aliasing of matrices, relatively commonly.</li>
</ul></li>
<li><p>reading the padding bytes of structs has to be allowed, eg to support (in some cases, not always) polymorphic bytewise operations such as copying, and perhaps also memcmp, marshalling, encryption, and hashing (deferring what one knows about the results of such reads for a moment). It's not clear how much the latter operations have to be supported. Jens+Martin think yes; Peter is skeptical. We would like more data. Atomic cmpxchg on large structs, implemented with locks, would do such a memcmp/memcpy combination (in fact is described as such in the standard).</p></li>
<li><p>for reads of these representation and padding bytes (they might not be treated identically, but we don't so far see any reason why not to), and of any other uninitialised value that one doesn't deem to be programmer errors, one could either:</p>
<ol style="list-style-type: decimal">
<li>regard them as holding stable concrete values - but this is inconsistent with current behaviour for some compilers, or</li>
<li>regard them as holding wobbly values, but with a memcpy (or other bytewise read and write) as concretising them to a nondeterministically chosen concrete value in the target (we think this is ugly), or</li>
<li><p>regard them as holding wobbly values that are propagated as wobbly values by memcpy (or other bytewise read and write), and then either:</p>
<ol style="list-style-type: lower-alpha">
<li>regard it as a programmer error (expressed either with UB or otherwise as below) to operate on them, or</li>
<li>propagate wobbliness through operations (including conversions), except for UB where some concrete value would give UB (e.g. division by zero) (this is what Cerberus does at present)</li>
</ol></li>
</ol>
<ul>
<li><p>in cases 2 and 3, for padding bytes, the wobbliness of the source values could be either:</p>
<ol style="list-style-type: lower-roman">
<li>intrinsic to the padding locations - uninitialisable, whatever happens, or</li>
<li>subject to being overwritten by explicit writes of non-wobbly values to padding, but reset to wobbly by preceding-adjacent or whole-struct writes.</li>
</ol></li>
</ul></li>
<li><p>the answers to these questions determine e.g. whether one can memcpy a partially initialised struct (perhaps containing padding) and then get a guarantee that a memcmp would compare equal. It's unclear whether this is a hard requirement for the semantics. Currently gcc seems to guarantee it, and so does clang head (though not older versions) for copy-and-compare, but not always if there's also some arithmetic.</p></li>
<li><p>we think it's important for the programmer to have some way to sanitise padding, in cases where they have to exclude bad information flow. This rules out the option (i) of padding bytes being intrinsically wobbly.</p></li>
<li><p>all other cases of reading uninitialised variables can be regarded as programmer errors</p></li>
<li><p>for these, we could either:</p>
<ol start="24" style="list-style-type: lower-alpha">
<li>make them always UB (which is classically what ISO C would do)</li>
<li>make them, at the implementation's per-instance choice, either a compile-time or a runtime error (a trap), or a use-time nondeterministic particular concrete value. This is a bit like the current ISO semantics for conversion, 6.3.1.3. This lets implementations detect and report errors wherever they can, while somewhat limiting &quot;surprising&quot; optimisations arising from UB. (This approach could also be applied to some other UBs.)</li>
<li>make them wobbly, with one of the above options</li>
</ol></li>
</ul>
</body>
</html>
