<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Kayvan Memarian, Peter Sewell. University of Cambridge" />
  <meta name="date" content="2021-03-09" />
  <title>Clarifying uninitialised reads v5 - working draft</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Clarifying uninitialised reads v5 - working draft</h1>
<h2 class="author">Kayvan Memarian, Peter Sewell. University of Cambridge</h2>
<h3 class="date">2021-03-09</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#related-papers"><span class="toc-section-number">1</span> Related papers</a></li>
<li><a href="#uninitialised-reads"><span class="toc-section-number">2</span> Uninitialised reads</a><ul>
<li><a href="#from-the-programmer-and-existing-code-points-of-view"><span class="toc-section-number">2.1</span> From the programmer and existing-code points of view</a></li>
<li><a href="#compiler-behaviour"><span class="toc-section-number">2.2</span> Compiler behaviour</a></li>
<li><a href="#c"><span class="toc-section-number">2.3</span> C++</a></li>
<li><a href="#the-current-c-standard-text---uninitialised-values"><span class="toc-section-number">2.4</span> The current C standard text - uninitialised values</a></li>
<li><a href="#design-questions---trap-representations"><span class="toc-section-number">2.5</span> Design questions - trap representations</a></li>
<li><a href="#design-questions---unspecified-values"><span class="toc-section-number">2.6</span> Design questions - unspecified values</a><ul>
<li><a href="#reading-uninitialised-values"><span class="toc-section-number">2.6.1</span> Reading uninitialised values</a></li>
<li><a href="#summary-from-meeting"><span class="toc-section-number">2.6.2</span> Summary from meeting:</a></li>
<li><a href="#stability-of-uninitialised-values"><span class="toc-section-number">2.6.3</span> Stability of uninitialised values</a></li>
<li><a href="#q52-do-operations-on-unspecified-values-result-in-unspecified-values"><span class="toc-section-number">2.6.4</span> Q52 Do operations on unspecified values result in unspecified values?</a></li>
<li><a href="#q54-must-unspecified-values-be-considered-daemonically-for-identification-of-other-possible-undefined-behaviours"><span class="toc-section-number">2.6.5</span> Q54 Must unspecified values be considered daemonically for identification of other possible undefined behaviours?</a></li>
<li><a href="#q50-can-control-flow-choices-based-on-unspecified-values-be-assumed-to-make-an-unspecified-arbitrary-choice-not-giving-rise-to-undefined-behaviour"><span class="toc-section-number">2.6.6</span> Q50 Can control-flow choices based on unspecified values be assumed to make an unspecified (arbitrary) choice (not giving rise to undefined behaviour)?</a></li>
<li><a href="#q49-can-library-calls-with-unspecified-value-arguments-be-assumed-to-execute-with-an-arbitrary-choice-of-a-concrete-value-not-necessarily-giving-rise-to-undefined-behaviour"><span class="toc-section-number">2.6.7</span> Q49 Can library calls with unspecified-value arguments be assumed to execute with an arbitrary choice of a concrete value (not necessarily giving rise to undefined behaviour)?</a></li>
<li><a href="#can-a-structure-containing-an-uninitialised-member-can-be-copied-as-a-whole"><span class="toc-section-number">2.6.8</span> Can a structure containing an uninitialised member can be copied as a whole?</a></li>
<li><a href="#can-a-union-as-a-whole-be-an-unspecified-value"><span class="toc-section-number">2.6.9</span> Can a union-as-a-whole be an unspecified value?</a></li>
<li><a href="#can-a-structure-containing-an-uninitialised-member-can-be-copied-member-by-member"><span class="toc-section-number">2.6.10</span> Can a structure containing an uninitialised member can be copied member-by-member?</a></li>
<li><a href="#q56-given-multiple-bitfields-that-may-be-in-the-same-word-can-one-be-a-well-defined-value-while-another-is-an-unspecified-value"><span class="toc-section-number">2.6.11</span> Q56 Given multiple bitfields that may be in the same word, can one be a well-defined value while another is an unspecified value?</a></li>
<li><a href="#q57-are-the-representation-bytes-of-an-unspecified-value-themselves-also-unspecified-values-not-an-arbitrary-choice-of-concrete-byte-values"><span class="toc-section-number">2.6.12</span> Q57 Are the representation bytes of an unspecified value themselves also unspecified values? (not an arbitrary choice of concrete byte values)</a></li>
<li><a href="#q58-if-one-writes-some-but-not-all-of-the-representation-bytes-of-an-uninitialized-value-do-the-other-representation-bytes-still-hold-unspecified-values"><span class="toc-section-number">2.6.13</span> Q58 If one writes some but not all of the representation bytes of an uninitialized value, do the other representation bytes still hold unspecified values?</a></li>
<li><a href="#q59-if-one-writes-some-but-not-all-of-the-representation-bytes-of-an-uninitialized-value-does-a-read-of-the-whole-value-still-give-an-unspecified-value"><span class="toc-section-number">2.6.14</span> Q59 If one writes some but not all of the representation bytes of an uninitialized value, does a read of the whole value still give an unspecified value?</a></li>
</ul></li>
<li><a href="#summary-of-proposal"><span class="toc-section-number">2.7</span> Summary of proposal</a></li>
</ul></li>
<li><a href="#padding-bytes"><span class="toc-section-number">3</span> Padding bytes</a><ul>
<li><a href="#the-current-c-standard-text---padding-bytes"><span class="toc-section-number">3.1</span> The current C standard text - padding bytes</a></li>
<li><a href="#from-the-programmer-and-existing-code-points-of-view-1"><span class="toc-section-number">3.2</span> From the programmer and existing-code points of view</a></li>
<li><a href="#compiler-behaviour-1"><span class="toc-section-number">3.3</span> Compiler behaviour</a></li>
<li><a href="#design-questions---padding-bytes"><span class="toc-section-number">3.4</span> Design questions - padding bytes</a><ul>
<li><a href="#q61.-after-an-explicit-write-of-a-padding-byte-does-that-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="toc-section-number">3.4.1</span> Q61. After an explicit write of a padding byte, does that byte hold a well-defined value? (not an unspecified value)</a></li>
<li><a href="#q62.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-the-whole-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="toc-section-number">3.4.2</span> Q62. After an explicit write of a padding byte followed by a write to the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)</a></li>
<li><a href="#q63.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-adjacent-members-of-the-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="toc-section-number">3.4.3</span> Q63. After an explicit write of a padding byte followed by a write to adjacent members of the structure, does the padding byte hold a well-defined value? (not an unspecified value)</a></li>
<li><a href="#q65.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-a-non-adjacent-member-of-the-whole-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="toc-section-number">3.4.4</span> Q65. After an explicit write of a padding byte followed by a write to a non-adjacent member of the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)</a></li>
<li><a href="#q66.-after-an-explicit-write-of-a-padding-byte-followed-by-a-writes-to-adjacent-members-of-the-whole-structure-but-accessed-via-pointers-to-the-members-rather-than-via-the-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="toc-section-number">3.4.5</span> Q66. After an explicit write of a padding byte followed by a writes to adjacent members of the whole structure, but accessed via pointers to the members rather than via the structure, does the padding byte hold a well-defined value? (not an unspecified value)</a></li>
<li><a href="#q60.-can-structure-copy-copy-padding"><span class="toc-section-number">3.4.6</span> Q60. Can structure-copy copy padding?</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>Reading uninitialised values and padding bytes have many conceivable semantics in C, there are conflicting demands and expectations, and the current standard text is not clear about all aspects. This note summarises the design space with a series of questions.</p>
<p>WG14 has previously (DR451 CR) concluded &quot;The committee agrees that this area would benefit from a new definition of something akin to a 'wobbly' value and that this should be considered in any subsequent revision of this standard. The committee also notes that padding bytes within structures are possibly a distinct form of 'wobbly' representation.&quot;. This note explores the design space for what that might mean in detail.</p>
<p>This is another part of the C memory object model, orthogonal to provenance.</p>
<h1 id="related-papers"><span class="header-section-number">1</span> Related papers</h1>
<p>This is a revision of part of <a href="http://www.cl.cam.ac.uk/users/pes20/cerberus/notes98-2018-04-21-uninit-v4.html">notes98: Clarifying Uninitialised Values (Q47-Q59) v4 - working draft Kayvan Memarian, Victor Gomes, Peter Sewell. University of Cambridge 2018-04-21</a> and the padding discussion of <a href="http://www.cl.cam.ac.uk/users/pes20/cerberus/notes30.pdf">N2013</a>.</p>
<p>notes98 was a WG14 Brno meeting working draft that did not have an N-number; it was a revision of <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2220.htm">N2220</a> and <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2221.htm">N2221</a>. The latter was a revision of N2089. N2089 was based on N2012 (Section 2), adding a concrete Technical Corrigendum proposal for discussion, revising the text, and adding concrete examples from N2013.</p>
<p><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2223.htm">N2223: Clarifying the C Memory Object Model: Introduction to N2219 - N2222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2221.htm">N2221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2220.htm">N2220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2089.pdf">N2089</a>, Section 2 of <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2012.htm">N2012</a>, Sections 3.1 and 3.2 (Q48-59) of <a href="http://www.cl.cam.ac.uk/users/pes20/cerberus/notes30.pdf">N2013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_338.htm">DR338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/summary.htm#dr_451">DR451</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1793.pdf">N1793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1818.pdf">N1818</a>.</p>
<p>Papers by Juneyoung Lee et al.: (PLDI 2017) Taming Undefined Behavior in LLVM; (OOPSLA 2018) Reconciling High-level Optimizations and Low-level Code in LLVM.</p>
<h1 id="uninitialised-reads"><span class="header-section-number">2</span> Uninitialised reads</h1>
<h2 id="from-the-programmer-and-existing-code-points-of-view"><span class="header-section-number">2.1</span> From the programmer and existing-code points of view</h2>
<p>In most cases, reading an uninitialised value is a programmer error, and it is/would be desirable for implementations to report this promptly, at compile-time or run-time, wherever they reasonably can.</p>
<p>There are some significant exceptions, where reading uninitialised values is either desirable or is endemic in practice:</p>
<ul>
<li><p>It should be possible to copy a partially initialised struct, either explicitly by a struct assignment, or implicitly as a function-call arguments, or by <code>memcpy</code>.</p></li>
<li><p>There's an occasional but real use-case of debug printing partially initialised structs. Making that UB could be very confusing if it gets exploited by compilers.</p></li>
<li><p>Sometimes sets of flags (stored as bits in integer-typed variables, not as bitfields) are initialised incrementally, e.g. by reading a possibly-uninitialised value, doing some arithmetic or bitwise-logical operations on it, and storing the result back. Kostya Serebryany reported some time ago that this had to be allowed in their sanitisers, as there are too many instances to require them to be fixed.</p></li>
</ul>
<p>That said, we guess (without evidence) that not much memory is used in this way, and hence that the runtime/code-size cost of requiring zero-initialisation would be small. Although that might reduce error-detection opportunities, e.g. if this is allowed by special-casing some set-bit operations.</p>
<ul>
<li><p>Some polymorphic bytewise operations on structs should be supported e.g. (library or user) implementations of <code>memcpy</code> and <code>memcmp</code>, serialisation, encryption, and hashing. These necessarily will read and write any uninitialised members and padding bytes in the struct layout, and there should be some way for the programmer to make them well-defined and deterministic.</p></li>
<li><p>Closely related to that, for struct copies and for those polymorphic bytewise operations, there should be some way (either always on by default, or enabled by some compiler option or annotation, or some specific programming idiom) for the user to ensure they have results that cannot leak potentially-security-relevant information.</p></li>
</ul>
<p>Our 2015 survey of C experts gave basically bimodal results between options (a) and (d) below. We asked (survey question 2/15): Is reading an uninitialised variable or struct member (with a current mainstream compiler):</p>
<ul>
<li><p>139 (43%) undefined behaviour (meaning that the compiler is free to arbitrarily miscompile the program, with or without a warning)</p></li>
<li><p>42 (13%) going to make the result of any expression involving that value unpredictable</p></li>
<li><p>21 (6%) going to give an arbitrary and unstable value (maybe with a different value if you read again)</p></li>
<li><p>112 (35%) going to give an arbitrary but stable value (with the same value if you read again)</p></li>
</ul>
<p>A straw poll at EuroLLVM 2018 gave roughly the same distribution. The survey comments suggest that some (but perhaps not much) real code depends on one of the stronger semantics.</p>
<h2 id="compiler-behaviour"><span class="header-section-number">2.2</span> Compiler behaviour</h2>
<p>Compilers do sometimes optimise in ways that make multiple reads of an uninitialised value observably different (e.g. as a natural consequence of SSA form).</p>
<p>There is ongoing work on the LLVM poison, freeze, and undef, since we started to look at these questions. We don't know the current state of that in detail, but some preliminary discussions have suggested that the C source semantics proposed here and the poison+freeze semantics proposed for LLVM can be made consistent. We also don't know the gcc internals.</p>
<h2 id="c"><span class="header-section-number">2.3</span> C++</h2>
<p>It's probably essential for C and C++ to have broadly the same semantics for this, but we don't discuss the current C++ semantics in this note.</p>
<h2 id="the-current-c-standard-text---uninitialised-values"><span class="header-section-number">2.4</span> The current C standard text - uninitialised values</h2>
<p>3.19.2 &quot;indeterminate value: either an unspecified value or a trap representation&quot;</p>
<p>3.19.3 &quot;unspecified value: valid value of the relevant type where this International Standard imposes no requirements on which value is chosen in any instance&quot;</p>
<p>3.19.4 &quot;trap representation: an object representation that need not represent a value of the object type&quot;</p>
<p>6.2.4p6,7 For objects with automatic storage duration &quot;The initial value of the object is indeterminate.&quot;</p>
<p>6.2.6.1p5 &quot;Certain object representations need not represent a value of the object type. If the stored value of an object has such a representation and is read by an lvalue expression that does not have character type, the behavior is undefined. If such a representation is produced by a side effect that modifies all or any part of the object by an lvalue expression that does not have character type, the behavior is undefined. 54) Such a representation is called a trap representation.&quot;</p>
<p>6.2.6.1p6 &quot;When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values. 51) The value of a structure or union object is never a trap representation, even though the value of a member of the structure or union object may be a trap representation.&quot;</p>
<p>6.2.6.1p7 &quot;When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values.&quot;</p>
<p>6.3.2.1p2 &quot;...If the lvalue designates an object of automatic storage duration that could have been declared with the register storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.&quot;</p>
<h2 id="design-questions---trap-representations"><span class="header-section-number">2.5</span> Design questions - trap representations</h2>
<p>The 3.19.4 standard text is clear that trap representations are object <em>representations</em>, not abstract values of some kind. It follows that for many common implementations, many types cannot have trap representations, because there are no object representations that do not represent a value. (<code>_Bool</code> is the main type that often can have trap representations; standard integer types usually cannot.)</p>
<p>However, this is confused by 6.2.6.1p6, which speaks of values being trap representations.</p>
<p>We assume the former reading, and propose to clarify the terminology to make that plain - c.f. the note by Jens Gustedt and Martin Uecker.</p>
<h2 id="design-questions---unspecified-values"><span class="header-section-number">2.6</span> Design questions - unspecified values</h2>
<h3 id="reading-uninitialised-values"><span class="header-section-number">2.6.1</span> Reading uninitialised values</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example trap_representation_1.c 
<span class="dt">int</span> main() {
  <span class="dt">int</span> i;
  <span class="dt">int</span> *p = &amp;i;
  <span class="dt">int</span> j=i;   <span class="co">// should this have undefined behaviour?</span>
  <span class="co">// note that i is read but the value is not used</span>
}

Example trap_representation_2.c 
<span class="dt">int</span> main() {
  <span class="dt">int</span> i;
  <span class="dt">int</span> j=i;   <span class="co">// should this have undefined behaviour?</span>
  <span class="co">// note that i is read but the value is not used</span>
}</code></pre></div>
<p>In the current standard, for implementations in which <code>int</code> has no trap representations (so 6.2.6.1p5 is irrelevant), the first has defined behaviour. By 6.2.4p6 the value is indeterminate, so by the definition of indeterminate values, where there are no trap representations at <code>int</code>, the result is an unspecified value.</p>
<p>In the current standard, the second has undefined behaviour (by 6.3.2.1p2).</p>
<p>Historical question: what was the intent of the address-taken distinction? From previous discussion, it seems to have been an attempt to model the Itanium NaT not a thing behaviour, but it's not clear whether it's sufficient for that (c.f. mail with Hans Boehm, who pointed out that inlining and optimisation might keep values in registers, potentially with a NaT flag, even if in the source its address is taken).</p>
<p>How do we think reads of uninitialised address-taken variables are used in practice? Only for reading their representation bytes and when reading structs as a whole? (And for incremental bitwise initialisation.)</p>
<p>If we could make reads of uninitialised variables always UB, or allow such reads but make it UB to use the results in any way except for a store, or either of those but allowing representation-byte reads, we could have a simpler semantics that might be equally useful. But we hesitate to propose making potential existing code UB, so we don't pursue those options in detail in this note. We could be guided by sanitiser and C++ experience?</p>
<p>Design question: for reads of uninitialised variables (at types that do not have trap representations):</p>
<ol style="list-style-type: decimal">
<li>always</li>
<li>only if their address has been taken</li>
<li>never</li>
<li>other</li>
</ol>
<h3 id="summary-from-meeting"><span class="header-section-number">2.6.2</span> Summary from meeting:</h3>
<ul>
<li><p>trap representations exist (a) to support hardware, and (b) for conformance wo the &quot;language-independent arithmetic&quot; (LIA) standard, which gave rise to Annex H. Now we have less pressure to conform to that.</p></li>
<li><p>the address-taken rule was a compromise to support Itanium NaT while not impacting other users.</p></li>
<li><p>there is agreement that the current terminology is confusing and we could/should change</p></li>
<li><p>there are some real cases where it should be an error to load specific object representations, though they are relatively rare. We could require implementations to document those.</p></li>
<li><p>there are some real cases where it should be an error to operate on specific object representations (eg <code>_Bool</code>).</p></li>
</ul>
<ol style="list-style-type: decimal">
<li>always defined behaviour, as an unspecified value - 3</li>
<li>at implementations's per-instance choice, either compile-time error or unspecified value - 3</li>
<li>always undefined behaviour - 12</li>
<li>other - 0</li>
</ol>
<hr />
<p>final</p>
<p>Design question: at types that do not have trap representations, should we allow non-character reads of scalar uninitialised variables:</p>
<ol style="list-style-type: decimal">
<li>always defined behaviour, as an unspecified value 0</li>
<li>at implementations's per-instance choice, either compile-time error, or non-silent runtime error, or unspecified value 8</li>
<li>always undefined behaviour 10</li>
<li>other 0</li>
</ol>
<hr />
<h3 id="stability-of-uninitialised-values"><span class="header-section-number">2.6.3</span> Stability of uninitialised values</h3>
<p>In the absence of any writes, is the result of reading an uninitialised object potentially unstable, i.e., can multiple usages of it give different results?</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_stability.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
  <span class="co">// assume here that int has no trap representations and </span>
  <span class="co">// that printing an unspecified value is not itself </span>
  <span class="co">// undefined behaviour</span>
  <span class="dt">int</span> i;
  <span class="dt">int</span> *p = &amp;i;
  <span class="co">// can the following print different values?</span>
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
}</code></pre></div>
<p>The current standard text is not completely clear: the 3.19.3 definition of unspecified value says &quot;valid value of the relevant type where this International Standard imposes no requirements on which value is chosen in any instance&quot;, but it's unclear whether the &quot;instance&quot; is per-initialisation or per-read, or whether &quot;uninitialisedness&quot; propagates through expression evaluation.</p>
<p>Clang sometimes prints distinct values here (this is consistent with the Clang internal documentation). Accordingly, we think the answer has to be &quot;yes&quot;.</p>
<p>Design question: In the absence of any writes, is the result of reading an uninitialised object potentially unstable, i.e., can multiple usages of it give different results?</p>
<ol style="list-style-type: decimal">
<li>yes</li>
<li>no</li>
<li>other</li>
</ol>
<h3 id="q52-do-operations-on-unspecified-values-result-in-unspecified-values"><span class="header-section-number">2.6.4</span> Q52 Do operations on unspecified values result in unspecified values?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_strictness_and_1.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
  <span class="dt">unsigned</span> <span class="dt">char</span> c; 
  <span class="dt">unsigned</span> <span class="dt">char</span> *p=&amp;c;
  <span class="dt">unsigned</span> <span class="dt">char</span> c2 = (c | <span class="dv">1</span>);
  <span class="dt">unsigned</span> <span class="dt">char</span> c3 = (c2 &amp; <span class="dv">1</span>);
  <span class="co">// does c3 hold an unspecified value (not 1)?  </span>
  printf(<span class="st">&quot;c=%i  c2=%i  c3=%i</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">int</span>)c,(<span class="dt">int</span>)c2,(<span class="dt">int</span>)c3);
}</code></pre></div>
<p>(An LLVM developer remarked (some time ago) that different parts of LLVM assume that undef is propagated aggressively or that it represents an unknown particular number.)</p>
<p>Design question: either</p>
<ol style="list-style-type: decimal">
<li>Unspecified values are symbolic, i.e. operations on unspecified values result in unspecified-value tokens (modulo other UBs; see the next question).</li>
<li>Unspecified values exist only in the abstract-machine memory, not in expression evaluation, and a read of an unspecified value makes a read-time nondeterministic choice of a concrete value of the appropriate type.</li>
<li>Other</li>
</ol>
<p>In Option 1, the read of c will give the unspecified value token, the result of the binary operation |, if given at least one unspecified-value arguments, will also be the unspecified value token, which will be written to c2. Likewise, the binary &amp; will be strict in unspecified-value-ness, and c3 will end up as the unspecified value. The printf will then make nondeterministic choices for each of these, allowing arbitrary character-valued integers to be printed by implementations.</p>
<p>Design question: For option 1, should the unspecified value token be:</p>
<ol style="list-style-type: lower-alpha">
<li>a per-scalar-type-object entity</li>
<li>a per-bit entity</li>
<li>other</li>
</ol>
<p>We think a.</p>
<p>Note that (a) makes incremental bitwise initialisation not useful. It's hard to imagine that such initialisation is desirable in new code, but it may exist; we don't know how common it is.</p>
<p>It would also make the N1793 Fig.4 printhexdigit not useful when applied to an uninitialised structure member.</p>
<p>Option 1a is implemented in the Cerberus C semantics, so we have experience of working through all the details.</p>
<h3 id="q54-must-unspecified-values-be-considered-daemonically-for-identification-of-other-possible-undefined-behaviours"><span class="header-section-number">2.6.5</span> Q54 Must unspecified values be considered daemonically for identification of other possible undefined behaviours?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_daemonic_1.c
<span class="dt">int</span> main() {
  <span class="dt">int</span> i;
  <span class="dt">int</span> *p = &amp;i;
  <span class="dt">int</span> j = i;   
  <span class="dt">int</span> k = <span class="dv">1</span>/j; <span class="co">// should this have undefined behaviour?</span>
}</code></pre></div>
<p>The division operation has undefined behaviour for certain concrete argument values, i.e. 0, to accommodate implementation behaviour. If there is an abstract-machine execution in which the second argument is an unspecified value, then a corresponding execution of an actual implementation might divide by zero, so in the abstract machine division should be daemonic: division by an unspecified value should be just as &quot;bad&quot; as division by zero. The same holds for other partial operations and library calls.</p>
<p>For Option 1 (symbolic unspecified values) this seems forced.</p>
<p>For Option 2 (read-time nondeterministic choices of concrete values), the UB will arise on one execution and hence the program will be UB.</p>
<h3 id="q50-can-control-flow-choices-based-on-unspecified-values-be-assumed-to-make-an-unspecified-arbitrary-choice-not-giving-rise-to-undefined-behaviour"><span class="header-section-number">2.6.6</span> Q50 Can control-flow choices based on unspecified values be assumed to make an unspecified (arbitrary) choice (not giving rise to undefined behaviour)?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_control_flow_choice.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() 
{
  <span class="dt">unsigned</span> <span class="dt">char</span> c; 
  <span class="dt">unsigned</span> <span class="dt">char</span> *p = &amp;c;
  <span class="cf">if</span> (c == <span class="ch">&#39;a&#39;</span>) 
    printf(<span class="st">&quot;equal</span><span class="sc">\n</span><span class="st">&quot;</span>);
  <span class="cf">else</span>
    printf(<span class="st">&quot;nonequal</span><span class="sc">\n</span><span class="st">&quot;</span>);
  <span class="co">// should this have defined behaviour?</span>
}</code></pre></div>
<p>We suggest &quot;yes&quot;:</p>
<ol style="list-style-type: lower-alpha">
<li>permit a runtime unspecified (nondeterministic) choice at any control-flow choice between specified alternatives based on an unspecified values.</li>
<li>more conservatively, one could treat any control-flow choice whose controlling expression has an unspecified value as having undefined behaviour.</li>
<li>other</li>
</ol>
<p>The only potential argument against (a) that we are aware of is (as noted by Joseph Myers) jump tables indexed by an unspecified value, if implementations don't do a range check. Do they? That seems likely to lead to security weaknesses.</p>
<p>Computed gotos (if they were allowed in the standard) on unspecified values should give undefined behaviour in any case.</p>
<p>IIRC in LLVM branches on poison are UB, so choosing (a) for the source semantics would necessitate a freeze for controlling expressions that might be unspecified values.</p>
<h3 id="q49-can-library-calls-with-unspecified-value-arguments-be-assumed-to-execute-with-an-arbitrary-choice-of-a-concrete-value-not-necessarily-giving-rise-to-undefined-behaviour"><span class="header-section-number">2.6.7</span> Q49 Can library calls with unspecified-value arguments be assumed to execute with an arbitrary choice of a concrete value (not necessarily giving rise to undefined behaviour)?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_library_call_argument.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() 
{
  <span class="dt">unsigned</span> <span class="dt">char</span> c; 
  <span class="dt">unsigned</span> <span class="dt">char</span> *p = &amp;c;
  printf(<span class="st">&quot;char 0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">unsigned</span> <span class="dt">int</span>)c);
  <span class="co">// should this have defined behaviour?</span>
}</code></pre></div>
<p>The DR451 CR says &quot;library functions will exhibit undefined behavior when used on indeterminate values&quot; but here we are more specifically looking at unspecified values. We see no benefit from making this undefined behaviour, and we are not aware that compilers assume so. It prevents (e.g.) serialising or debug printing of partially uninitialised structs, or (if padding bytes are treated the same as other uninitialised values) byte-by-byte serialising of structs containing padding. Accordingly, we suggest that library functions such as printf, when called with an unspecified value, are executed by first making an unspecified (nondeterministic) choice at call-time of a concrete value. This permits the instability of uninitialised values that we see in practice.</p>
<h3 id="can-a-structure-containing-an-uninitialised-member-can-be-copied-as-a-whole"><span class="header-section-number">2.6.8</span> Can a structure containing an uninitialised member can be copied as a whole?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_struct_copy.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> i1; <span class="dt">int</span> i2; } st;
<span class="dt">int</span> main() {
  st s1;
  s1.i1 = <span class="dv">1</span>;
  st s2;
  s2 = s1; <span class="co">// should this have defined behaviour?</span>
  printf(<span class="st">&quot;s2.i1=%i</span><span class="sc">\n</span><span class="st">&quot;</span>,s2.i1);
}</code></pre></div>
<p>There are two versions of this question: one where the uninitialised member might be a trap representation and one where it cannot be, and so is known to be an unspecified value.</p>
<p>In either case, this seems to be relied on in practice, and the 6.2.6.1p6 &quot;The value of a structure or union object is never a trap representation&quot; suggests the previous WG14 intent was to permit it.</p>
<p>In the Option 1 (symbolic unspecified-value tokens) semantics, the copy will have the unspecified value token for the same member; the struct as a whole will not become an unspecified value (i.e. forming a structure value should not be strict in unspecified-value-ness). In the Option 2 (read-time nondeterministic value) semantics, the copy would have a nondeterministically chosen but thereafter fixed concrete value.</p>
<h3 id="can-a-union-as-a-whole-be-an-unspecified-value"><span class="header-section-number">2.6.9</span> Can a union-as-a-whole be an unspecified value?</h3>
<p>In principle there is a similar question for unions: can a union value as a whole be an unspecified value? There might be a real semantic difference, between an unspecified value as whole and a union that contains a specific member which itself is an unspecified value. But it's unclear whether there is a test in ISO C that distinguishes the two. We presume &quot;no&quot;.</p>
<h3 id="can-a-structure-containing-an-uninitialised-member-can-be-copied-member-by-member"><span class="header-section-number">2.6.10</span> Can a structure containing an uninitialised member can be copied member-by-member?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_struct_copy_2.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">int</span> i1; <span class="dt">_Bool</span> b2; } st;
<span class="dt">int</span> main() {
  st s1;
  s1.i1 = <span class="dv">1</span>;
  st s2;
  s2.i1 = s1.i1; 
  s2.b2 = s1.b2; <span class="co">// does this have defined behaviour?</span>
  printf(<span class="st">&quot;s2.i1=%i</span><span class="sc">\n</span><span class="st">&quot;</span>,s2.i1);
}</code></pre></div>
<p>A unfortunate consequence of the choices so far is that a whole-struct copy and a member-by-member struct copy might not be equally well-defined: the former will always be defined behaviour, while the latter will be UB iff there is an uninitialised member of a type that has trap representations (e.g. <code>_Bool</code> on many platforms).</p>
<p>If we wanted to avoid this, we would have to change the notion of trap representation to give UB when any non-read/write operation is performed, rather than when any read is performed.</p>
<p>Design question: do we want to support copying of uninitialised values at types that have trap representations?</p>
<ol style="list-style-type: lower-alpha">
<li>yes</li>
<li>no</li>
<li>other</li>
</ol>
<p>We presume no for the time being, mostly to be conservative w.r.t. the current standard text.</p>
<h3 id="q56-given-multiple-bitfields-that-may-be-in-the-same-word-can-one-be-a-well-defined-value-while-another-is-an-unspecified-value"><span class="header-section-number">2.6.11</span> Q56 Given multiple bitfields that may be in the same word, can one be a well-defined value while another is an unspecified value?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example besson_blazy_wilke_bitfields_1u.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="kw">struct</span> f {
  <span class="dt">unsigned</span> <span class="dt">int</span> a0 : <span class="dv">1</span>; <span class="dt">unsigned</span> <span class="dt">int</span> a1 : <span class="dv">1</span>;
} bf ;

<span class="dt">int</span> main() {
  <span class="dt">unsigned</span> <span class="dt">int</span> a;
  bf.a1 = <span class="dv">1</span>; 
  a = bf.a1; 
  printf(<span class="st">&quot;a=%u</span><span class="sc">\n</span><span class="st">&quot;</span>,a);
}</code></pre></div>
<p>This example is from Besson, Blazy, and Wilke 2015.</p>
<p>For consistency with the rest of our per-leaf-value proposal, we suggest &quot;yes&quot;.</p>
<h3 id="q57-are-the-representation-bytes-of-an-unspecified-value-themselves-also-unspecified-values-not-an-arbitrary-choice-of-concrete-byte-values"><span class="header-section-number">2.6.12</span> Q57 Are the representation bytes of an unspecified value themselves also unspecified values? (not an arbitrary choice of concrete byte values)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_representation_bytes_1.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
  <span class="co">// assume here that the implementation-defined </span>
  <span class="co">// representation of int has no trap representations</span>
  <span class="dt">int</span> i;
  <span class="dt">unsigned</span> <span class="dt">char</span> c = * ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;i)); 
  <span class="co">// does c now hold an unspecified value?</span>
  printf(<span class="st">&quot;i=0x%x  c=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i,(<span class="dt">int</span>)c);
  printf(<span class="st">&quot;i=0x%x  c=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i,(<span class="dt">int</span>)c);
}</code></pre></div>
<p>The answer to this is unclear from multiple points of view: ISO C11 doesn't address the question; we don't know whether existing compilers assume these are unspecified values, and we don't know whether existing code relies on them not being unspecified values (e.g. by assuming that one can construct a deterministic hash from the representation bytes of an uninitialised value).</p>
<p>Options:</p>
<ol style="list-style-type: lower-alpha">
<li><p>If we've gone for Option 1 (symbolic unspecified-value tokens), it's stylistically consistent and technically straightforward to treat the representation bytes of uninitialised values the same way. That means representation-byte reads would give symbolic unspecified values, a bytewise <code>memcpy</code> will preserve unspecified-value-ness, and we can regard a read of a value for which any of the representation bytes have been written to be the unspecified-value token as returning an unspecified value. This is our (at least Memarian+Sewell) currently preferred option.</p></li>
<li><p>We could conceivably have Option 1 (symbolic unspecified-value tokens) but for non-<code>unsigned char</code> types make a nondeterministic choice of concrete representation bytes at object creation time. That would mean representation-bytes reads would deterministically return those concrete bytes, and a bytewise <code>memcpy</code> would copy them. But this isn't really self-consistent - e.g., repeated printf of an uninitialised value would show it as unstable (consistent with observed compiler behaviour), but repeated printf of a <code>memcpy</code> of that value would show an arbitrary but stable value.</p></li>
<li><p>Other.</p></li>
</ol>
<h3 id="q58-if-one-writes-some-but-not-all-of-the-representation-bytes-of-an-uninitialized-value-do-the-other-representation-bytes-still-hold-unspecified-values"><span class="header-section-number">2.6.13</span> Q58 If one writes some but not all of the representation bytes of an uninitialized value, do the other representation bytes still hold unspecified values?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_representation_bytes_4.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
  <span class="co">// assume here that the implementation-defined</span>
  <span class="co">// representation of int has no trap representations</span>
  <span class="dt">int</span> i;
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  <span class="dt">unsigned</span> <span class="dt">char</span> *cp = (<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;i);
  *(cp+<span class="dv">1</span>) = <span class="bn">0x22</span>;
  <span class="co">// does *cp now hold an unspecified value?</span>
  printf(<span class="st">&quot;*cp=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,*cp);
  printf(<span class="st">&quot;*cp=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,*cp);
}</code></pre></div>
<p>One could conceivably take the first such access as &quot;freezing&quot; the unspecified value and its representation bytes, but that would be pretty strange. The simplest choice is &quot;yes&quot;.</p>
<ol style="list-style-type: lower-alpha">
<li>yes</li>
<li>no</li>
<li>other</li>
</ol>
<h3 id="q59-if-one-writes-some-but-not-all-of-the-representation-bytes-of-an-uninitialized-value-does-a-read-of-the-whole-value-still-give-an-unspecified-value"><span class="header-section-number">2.6.14</span> Q59 If one writes some but not all of the representation bytes of an uninitialized value, does a read of the whole value still give an unspecified value?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example unspecified_value_representation_bytes_2.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
  <span class="co">// assume here that the implementation-defined</span>
  <span class="co">// representation of int has no trap representations</span>
  <span class="dt">int</span> i;
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  * (((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;i))+<span class="dv">1</span>) = <span class="bn">0x22</span>;
  <span class="co">// does i now hold an unspecified value?</span>
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  printf(<span class="st">&quot;i=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
}</code></pre></div>
<p>One could conceivably require that a read of the whole should give a nondeterministically chosen value consistent with the concretely written representation bytes, but that would be complex and not obviously useful.. The simplest choice is &quot;yes&quot;.</p>
<ol style="list-style-type: lower-alpha">
<li>yes</li>
<li>no</li>
<li>other</li>
</ol>
<h2 id="summary-of-proposal"><span class="header-section-number">2.7</span> Summary of proposal</h2>
<p>We could express the above Option 1 by a modest change to the C abstract machine: for any scalar type, we extend the set of values of that type with a symbolic &quot;unspecified value&quot; token, then we can give rules defining how that is propagated, e.g. if one adds an unspecified value and a concrete integer. The unspecified value token does not have a bit-level representation. notes</p>
<p><a href="http://www.cl.cam.ac.uk/users/pes20/cerberus/notes98-2018-04-21-uninit-v4.html">notes98: Clarifying Uninitialised Values (Q47-Q59) v4 - working draft Kayvan Memarian, Victor Gomes, Peter Sewell. University of Cambridge 2018-04-21</a> detailed a possible technical corrigendum for this.</p>
<p>As always, the &quot;as if&quot; rule applies: the fact that the abstract machine manipulates an explicit &quot;unspecified value&quot; token doesn't mean that implementations have to. Normal implementations may at compile-time but will not at runtime: at runtime they will typically have some arbitrary bit pattern where the abstract machine has the unspecified value token, and the looseness of the rules for operations on unspecified values licenses compiler optimisations.</p>
<p>This semantics seems to be a reasonable and coherent choice, with several benefits:</p>
<ul>
<li><p>it makes bytewise copying of uninitialised objects (and partially uninitialised objects) legal, e.g. by user-code analogues of memcpy;</p></li>
<li><p>it makes bytewise (un)serialisation of such objects legal, though with nondeterministic results for the values of uninitialised bytes as viewed on disc;</p></li>
<li><p>it permits SSA optimisations for unspecified values;</p></li>
</ul>
<p>However, there are some things it does not support:</p>
<ul>
<li><p>it does not support bytewise hashing or comparison of such objects, or (un)serialisation that involves compression, as the unspecified values will infect any computation more complex than a copy;</p></li>
<li><p>it does not support copying or (un)serialisation at larger than byte granularities, even with -fno-strict-aliasing, for the same reason; and</p></li>
<li><p>the semantics for printf and other library calls effectively presumes that their arguments are &quot;frozen&quot;, which isn't really coherent with the fact that they will be compiled by the same compiler.</p></li>
</ul>
<p>So all this should be discussed.</p>
<p>Perhaps there should be a language-level analogue of the &quot;freeze&quot; being introduced in LLVM, to support code that knowingly manipulates potentially uninitialised values. We do not here attempt to specify that.</p>
<p>If we are keeping the concept of trap representations, with _Bool as a type (possibly the only one in normal implementations) that has them, then copying a partly uninitialised struct member-by-member will give rise to UB. How about copying a partially uninitialised struct as a whole? Is this an argument for making _Bool have no trap representations, instead making it UB to use non-canonical values in boolean operations or control-flow choices?</p>
<h1 id="padding-bytes"><span class="header-section-number">3</span> Padding bytes</h1>
<h2 id="the-current-c-standard-text---padding-bytes"><span class="header-section-number">3.1</span> The current C standard text - padding bytes</h2>
<p>The standard has two quite distinct notions of padding: padding bytes in structures and unions, and padding bits within the representation of integer types. We focus here just on the former.</p>
<p>Padding can be added by an implementation between the members of a structure, or at the end of a structure or union, but not before the first member:</p>
<p>6.7.2.1p17 &quot;...There may be unnamed padding within a structure object, but not at its beginning.&quot;</p>
<p>6.7.2.1p19 &quot;There may be unnamed padding at the end of a structure or union.&quot;</p>
<p>Padding for (implicitly initialised) static or thread storage duration objects is initialised to zero:</p>
<p>6.7.9p10 &quot;If an object that has static or thread storage duration is not initialized explicitly, then: [...] any padding is initialized to zero bits&quot;</p>
<p>Curiously, that omits to specify the initialisation of padding for such an object that <em>is</em> initialised explicitly; that should presumably be fixed.</p>
<p>For automatic storage duration objects, the initialisation of padding is not described. All that is specified is that, if there is not an explicit initialiser, the abstract value is indeterminate:</p>
<p>6.7.9p10 &quot;If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.&quot;</p>
<p>When a value is written to a struct or union, the padding bytes &quot;take unspecified values&quot;:</p>
<p>6.2.6.1 &quot;When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values. 55)&quot;</p>
<p>(curiously, 6.2.6.1 Footnote 55 says &quot;Thus, for example, structure assignment need not copy any padding bits&quot;, but should refer to padding <em>bytes</em>; that should be fixed)</p>
<p>The force of &quot;including in a member object&quot; here is unclear: does that mean that if one writes to a struct member member, then the padding bytes of the enclosing struct, and perhaps also of any of its other members, also take unspecified values?</p>
<p>7.24.4.3p2 (<code>memcmp</code>) Footnote 331): &quot;The contents of &quot;holes&quot; used as padding for purposes of alignment within structure objects are indeterminate. [...]&quot;</p>
<p>It's unclear whether this applies just for <code>memcmp</code> or more generally. If padding bytes were intrinsically indeterminate, there would be <em>no</em> way for programmers to ensure an absence of information flow. Though as a footnote this is non-normative in any case.</p>
<h2 id="from-the-programmer-and-existing-code-points-of-view-1"><span class="header-section-number">3.2</span> From the programmer and existing-code points of view</h2>
<p>Usually programmers are not concerned with the contents of padding bytes. The exceptions are those we mentioned above:</p>
<ul>
<li><p>Some polymorphic bytewise operations on structs should be supported e.g. (library or user) implementations of <code>memcpy</code> and <code>memcmp</code>, serialisation, encryption, and hashing. These necessarily will read and write any uninitialised members and padding bytes in the struct layout, and there should be some way for the programmer to make them well-defined and deterministic.</p></li>
<li><p>Closely related to that, for struct copies and for those polymorphic bytewise operations, there should be some way (either always on by default, or enabled by some compiler option or annotation, or some specific programming idiom) for the user to ensure they have results that cannot leak potentially-security-relevant information.</p></li>
</ul>
<p>More specifically, (library or user bytewise) <code>memcpy</code> should always just work, while for some other operations one might expect the programmer to have to explicitly ensure that padding bytes have particular values.</p>
<p>Our survey had quite mixed responses:</p>
<p>[1/15] How predictable are reads from padding bytes?</p>
<p>If you zero all bytes of a struct and then write some of its members, do reads of the padding return zero? (e.g. for a bytewise CAS or hash of the struct, or to know that no security-relevant data has leaked into them.)</p>
<p>Will that work in normal C compilers?</p>
<ul>
<li>yes : 116 (36%)</li>
<li>only sometimes : 95 (29%)</li>
<li>no : 21 ( 6%)</li>
<li>don't know : 82 (25%)</li>
<li>I don't know what the question is asking : 3 ( 1%)</li>
<li>no response : 6</li>
</ul>
<p>Do you know of real code that relies on it?</p>
<ul>
<li>yes : 46 (14%)</li>
<li>yes, but it shouldn't : 31 ( 9%)</li>
<li>no, but there might well be : 158 (49%)</li>
<li>no, that would be crazy : 58 (18%)</li>
<li>don't know : 25 ( 7%)</li>
<li>no response : 5</li>
</ul>
<p>If it won't always work, is that because [check all that apply]:</p>
<ul>
<li>you've observed compilers write junk into padding bytes : 31</li>
<li>you think compilers will assume that padding bytes contain unspecified values and optimise away those reads : 120</li>
<li>no response : 150</li>
<li>other : 80</li>
</ul>
<h2 id="compiler-behaviour-1"><span class="header-section-number">3.3</span> Compiler behaviour</h2>
<p>We don't have good data about what modern compilers actually do for padding - comment would be welcome - but they might write to padding bytes for several reasons:</p>
<ul>
<li>if the target hardware architecture does not support the natural width of a write</li>
<li>if it combines writes to adjacent objects into one</li>
<li>if it converts a read-write pair (e.g. of a struct) into a <code>memcpy</code></li>
</ul>
<p>These might affect the padding within and after any members written, but nowhere else.</p>
<p>The fact that concurrent access to distinct members is allowed constrains wide writes to not touch unwritten members, at least in the absence of sophisticated analysis.</p>
<p>Compilers might also not write to or read from padding when one might expect them to, e.g. conceivably a <code>memcpy</code> of a struct could be optimised by omitting to copy some padding, and a read of padding could be omitted and replaced by use of whatever value happens to be in some processor register.</p>
<p>A struct copy could therefore either write to or not write any padding in the struct.</p>
<p>The values of writes to padding could come from a read of that padding in another struct of the same type (e.g. in a struct copy), or from whatever value happens to be in some processor register, or be zero or another fixed value chosen by the compiler.</p>
<p>It's also conceivable that a compiler would reserve space in a structure or union type for its own purposes, e.g. for some bounds-checking or debug metadata, but we imagine that this does not actually happens in mainstream implementations.</p>
<h2 id="design-questions---padding-bytes"><span class="header-section-number">3.4</span> Design questions - padding bytes</h2>
<p>There are several options for the semantics of padding. Presuming one has adopted the Option 1 symbolic unspecified-value token semantics, the choices for padding include:</p>
<ol style="list-style-type: lower-alpha">
<li><p>regarding padding bytes as holding unspecified-value tokens throughout the lifetime of the object, irrespective of any writes to them</p></li>
<li><p>when a struct/union or a struct/union member is written, deeming the semantics as also having written unspecified-value tokens to all padding bytes of that struct/union (including of all sub-members)</p></li>
<li><p>when a member is written, deeming the semantics as also having written unspecified-value tokens to adjacent padding (and when a struct/union is written as a whole, deeming the semantics as also having written unspecified-value tokens to all padding bytes of that struct/union (including of all sub-members))</p></li>
<li><p>as (c) but &quot;following&quot; instead of &quot;adjacent&quot;: when a member is written, deeming the semantics as also having written unspecified-value tokens to subsequent padding (and when a struct/union is written as a whole, deeming the semantics as also having written unspecified-value tokens to all padding bytes of that struct/union (including of all sub-members))</p></li>
<li><p>as (d) but &quot;zeros&quot; instead of &quot;unspecified values&quot;: when a member is written, nondeterministically either deeming the semantics as having written zeros to the subsequent padding (and when a struct/union is written as a whole, deeming the semantics as also having written zeros to all padding bytes of that struct/union (including of all sub-members))</p></li>
<li><p>as (e) but nondeterministically also allowing a struct copy to either zero, copy the source padding, or leave the target padding unchanged (this would need to record padding values in abstract-machine struct values)</p></li>
<li><p>as (f) but also nondeterministically also allowing member copies to either zero, copy source padding, or leave the target padding unchanged (this would need padding values attached to all abstract-machine values, and it's not always clear what their read/write footprints should be, or what code is a &quot;member copy&quot;)</p></li>
</ol>
<p>Option (a) makes it impossible for programmers to control what's in the padding.</p>
<p>Options (b) and (c) are probably needlessly liberal for compilers.</p>
<p>Option (d) would be a plausible conservative-with-respect-to-current-implementations choice, but not very useful for programmers.</p>
<p>Options (e,f,g) aim to give programmers a way to maintain the invariant that padding is zero'd, e.g. where that matters for security. We're not sure which are (or could be made) sound w.r.t. current optimisations.</p>
<p>Similarly to effective types, it might be that the semantics has to consider lvalue construction, not just the lvalue type, e.g. to know what counts as a struct member write.</p>
<h3 id="q61.-after-an-explicit-write-of-a-padding-byte-does-that-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="header-section-number">3.4.1</span> Q61. After an explicit write of a padding byte, does that byte hold a well-defined value? (not an unspecified value)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_1.c
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s))
        + offset_padding;
      *p = <span class="ch">&#39;A&#39;</span>;
      <span class="dt">unsigned</span> <span class="dt">char</span> c1 = *p; 
      <span class="co">// does c1 hold &#39;A&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c1=%c</span><span class="sc">\n</span><span class="st">&quot;</span>,c1);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>For objects with static, thread, or automatic storage durations, and leaving aside unions, for each byte it's fixed whether its a padding byte or not for the lifetime of the object, and one could conceivably regard the padding bytes as being unspecified values irrespective of any explicit writes to them (for a union, the padding status of a byte depends on which member the union &quot;currently contains&quot;) (For objects with allocated storage duration, as malloc'd region can be reused, that would have to be intertwined with effective-type semantics, which is still unclear.) But this would give programmers no way to ensure the absence of information leaks.</p>
<p>If we've gone for Option 1 for uninitialised reads, it'd be straightforward to use the same mechanism for uninitialised padding bytes, and write the unspecified-value token to padding in some circumstances. That would let it be overwritten with a concrete value if desired.</p>
<h3 id="q62.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-the-whole-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="header-section-number">3.4.2</span> Q62. After an explicit write of a padding byte followed by a write to the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_2.c:
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = 
        ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s)) + offset_padding;
      *p = <span class="ch">&#39;B&#39;</span>;
      s = (st){ .c=<span class="ch">&#39;E&#39;</span>, .f=<span class="fl">1.0</span>, .i=<span class="dv">1</span>};
      <span class="dt">unsigned</span> <span class="dt">char</span> c2 = *p; 
      <span class="co">// does c2 hold &#39;B&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c2=0x%x</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">int</span>)c2);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Here we see reads both of <code>B</code> and of <code>0x0</code>. Changing the example to one in which the compiler might naturally use a 4-byte copy, we sometimes see an overwrite of the padding byte on the write of the struct value.</p>
<h3 id="q63.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-adjacent-members-of-the-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="header-section-number">3.4.3</span> Q63. After an explicit write of a padding byte followed by a write to adjacent members of the structure, does the padding byte hold a well-defined value? (not an unspecified value)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_7.c:
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = 
        ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s)) + offset_padding;
      *p = <span class="ch">&#39;C&#39;</span>;
      s.c = <span class="ch">&#39;A&#39;</span>;
      s.f = <span class="fl">1.0</span>;
      s.i = <span class="dv">42</span>;
      <span class="dt">unsigned</span> <span class="dt">char</span> c3 = *p; 
      <span class="co">// does c3 hold &#39;C&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c3=%c</span><span class="sc">\n</span><span class="st">&quot;</span>,c3);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>This is perhaps the most relevant of these cases in practice, covering the case where the whole footprint of the struct has been filled with zero before use, and also covering the case where all members of the struct have been written (and hence where compilers might coalesce the writes). By requiring the explicit write to be of zero, compilers could implement this either by preserving the in-memory padding byte value or by writing a constant zero to it. Whether that would be sound w.r.t. actual practice is unclear. But it would be useful.</p>
<h3 id="q65.-after-an-explicit-write-of-a-padding-byte-followed-by-a-write-to-a-non-adjacent-member-of-the-whole-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="header-section-number">3.4.4</span> Q65. After an explicit write of a padding byte followed by a write to a non-adjacent member of the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_5.c:
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = 
        ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s)) + offset_padding;
      *p = <span class="ch">&#39;C&#39;</span>;
      s.i = <span class="dv">42</span>;
      <span class="dt">unsigned</span> <span class="dt">char</span> c3 = *p; 
      <span class="co">// does c3 hold &#39;C&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c3=%c</span><span class="sc">\n</span><span class="st">&quot;</span>,c3);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h3 id="q66.-after-an-explicit-write-of-a-padding-byte-followed-by-a-writes-to-adjacent-members-of-the-whole-structure-but-accessed-via-pointers-to-the-members-rather-than-via-the-structure-does-the-padding-byte-hold-a-well-defined-value-not-an-unspecified-value"><span class="header-section-number">3.4.5</span> Q66. After an explicit write of a padding byte followed by a writes to adjacent members of the whole structure, but accessed via pointers to the members rather than via the structure, does the padding byte hold a well-defined value? (not an unspecified value)</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_6.c:
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="dt">void</span> g(<span class="dt">char</span> *c, <span class="dt">float</span> *f) {
  *c=<span class="ch">&#39;A&#39;</span>;
  *f=<span class="fl">1.0</span>;
}
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = 
        ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s)) + offset_padding;
      *p = <span class="ch">&#39;D&#39;</span>;
      g(&amp;s.c, &amp;s.f);
      <span class="dt">unsigned</span> <span class="dt">char</span> c4 = *p; 
      <span class="co">// does c4 hold &#39;D&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c4=%c</span><span class="sc">\n</span><span class="st">&quot;</span>,c4);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Compiler optimisations could perhaps recognise the accesses are to adjacent struct members and coalesce them.</p>
<h3 id="q60.-can-structure-copy-copy-padding"><span class="header-section-number">3.4.6</span> Q60. Can structure-copy copy padding?</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">Example padding_unspecified_value_1.c:
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span>
<span class="kw">typedef</span> <span class="kw">struct</span> { <span class="dt">char</span> c; <span class="dt">float</span> f; <span class="dt">int</span> i; } st;
<span class="dt">int</span> main() {
  <span class="co">// check there is a padding byte between c and f</span>
  <span class="dt">size_t</span> offset_padding = offsetof(st,c)+<span class="kw">sizeof</span>(<span class="dt">char</span>);
  <span class="cf">if</span> (offsetof(st,f)&gt;offset_padding) {
      st s; 
      <span class="dt">unsigned</span> <span class="dt">char</span> *p = ((<span class="dt">unsigned</span> <span class="dt">char</span>*)(&amp;s))
        + offset_padding;
      *p = <span class="ch">&#39;A&#39;</span>;
      <span class="dt">unsigned</span> <span class="dt">char</span> c1 = *p; 
      <span class="co">// does c1 hold &#39;A&#39;, not an unspecified value?</span>
      printf(<span class="st">&quot;c1=%c</span><span class="sc">\n</span><span class="st">&quot;</span>,c1);
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
</body>
</html>
